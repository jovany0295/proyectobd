{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\xiada\\\\Downloads\\\\PyoUz\\\\proyectobd\\\\asist\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\xiada\\\\Downloads\\\\PyoUz\\\\proyectobd\\\\asist\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"C:\\\\Users\\\\xiada\\\\Downloads\\\\PyoUz\\\\proyectobd\\\\asist\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridCellEditing } from './useGridCellEditing.new';\nimport { GridCellModes, GridEditModes } from '../../../models/gridEditRowModel';\nimport { useGridRowEditing } from './useGridRowEditing.new';\nimport { gridEditRowsStateSelector } from './gridEditRowsSelector';\nexport var editingStateInitializer = function editingStateInitializer(state) {\n  return _extends({}, state, {\n    editRows: {}\n  });\n};\nexport var useGridEditing = function useGridEditing(apiRef, props) {\n  useGridCellEditing(apiRef, props);\n  useGridRowEditing(apiRef, props);\n  var debounceMap = React.useRef({});\n  var isCellEditableProp = props.isCellEditable;\n  var isCellEditable = React.useCallback(function (params) {\n    if (params.rowNode.isAutoGenerated) {\n      return false;\n    }\n    if (!params.colDef.editable) {\n      return false;\n    }\n    if (!params.colDef.renderEditCell) {\n      return false;\n    }\n    if (isCellEditableProp) {\n      return isCellEditableProp(params);\n    }\n    if (params.rowNode.isPinned) {\n      return false;\n    }\n    return true;\n  }, [isCellEditableProp]);\n  var maybeDebounce = function maybeDebounce(id, field, debounceMs, callback) {\n    if (!debounceMs) {\n      callback();\n      return;\n    }\n    if (!debounceMap.current[id]) {\n      debounceMap.current[id] = {};\n    }\n    if (debounceMap.current[id][field]) {\n      var _debounceMap$current$ = _slicedToArray(debounceMap.current[id][field], 1),\n        _timeout = _debounceMap$current$[0];\n      clearTimeout(_timeout);\n    } // To run the callback immediatelly without waiting the timeout\n\n    var runImmediately = function runImmediately() {\n      var _debounceMap$current$2 = _slicedToArray(debounceMap.current[id][field], 1),\n        timeout = _debounceMap$current$2[0];\n      clearTimeout(timeout);\n      callback();\n      delete debounceMap.current[id][field];\n    };\n    var timeout = setTimeout(function () {\n      callback();\n      delete debounceMap.current[id][field];\n    }, debounceMs);\n    debounceMap.current[id][field] = [timeout, runImmediately];\n  };\n  React.useEffect(function () {\n    var debounces = debounceMap.current;\n    return function () {\n      Object.entries(debounces).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          id = _ref2[0],\n          fields = _ref2[1];\n        Object.keys(fields).forEach(function (field) {\n          var _debounces$id$field = _slicedToArray(debounces[id][field], 1),\n            timeout = _debounces$id$field[0];\n          clearTimeout(timeout);\n          delete debounces[id][field];\n        });\n      });\n    };\n  }, []);\n  var runPendingEditCellValueMutation = React.useCallback(function (id, field) {\n    if (!debounceMap.current[id]) {\n      return;\n    }\n    if (!field) {\n      Object.keys(debounceMap.current[id]).forEach(function (debouncedField) {\n        var _debounceMap$current$3 = _slicedToArray(debounceMap.current[id][debouncedField], 2),\n          runCallback = _debounceMap$current$3[1];\n        runCallback();\n      });\n    } else if (debounceMap.current[id][field]) {\n      var _debounceMap$current$4 = _slicedToArray(debounceMap.current[id][field], 2),\n        runCallback = _debounceMap$current$4[1];\n      runCallback();\n    }\n  }, []);\n  var setEditCellValue = React.useCallback(function (params) {\n    var id = params.id,\n      field = params.field,\n      debounceMs = params.debounceMs;\n    return new Promise(function (resolve) {\n      maybeDebounce(id, field, debounceMs, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var setEditCellValueToCall, result;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                setEditCellValueToCall = props.editMode === GridEditModes.Row ? apiRef.current.unstable_setRowEditingEditCellValue : apiRef.current.unstable_setCellEditingEditCellValue; // Check if the cell is in edit mode\n                // By the time this callback runs the user may have cancelled the editing\n                if (!(apiRef.current.getCellMode(id, field) === GridCellModes.Edit)) {\n                  _context.next = 6;\n                  break;\n                }\n                _context.next = 4;\n                return setEditCellValueToCall(params);\n              case 4:\n                result = _context.sent;\n                resolve(result);\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      })));\n    });\n  }, [apiRef, props.editMode]);\n  var getRowWithUpdatedValues = React.useCallback(function (id, field) {\n    return props.editMode === GridEditModes.Cell ? apiRef.current.unstable_getRowWithUpdatedValuesFromCellEditing(id, field) : apiRef.current.unstable_getRowWithUpdatedValuesFromRowEditing(id);\n  }, [apiRef, props.editMode]);\n  var getEditCellMeta = React.useCallback(function (id, field) {\n    var editingState = gridEditRowsStateSelector(apiRef.current.state);\n    return {\n      changeReason: editingState[id][field].changeReason\n    };\n  }, [apiRef]);\n  var editingSharedApi = {\n    isCellEditable: isCellEditable,\n    setEditCellValue: setEditCellValue,\n    unstable_runPendingEditCellValueMutation: runPendingEditCellValueMutation,\n    unstable_getRowWithUpdatedValues: getRowWithUpdatedValues,\n    unstable_getEditCellMeta: getEditCellMeta\n  };\n  useGridApiMethod(apiRef, editingSharedApi, 'EditingApi');\n};","map":null,"metadata":{},"sourceType":"module"}